import * as vscode from 'vscode';
import { AnalysisResult, Vulnerability } from '../types';
import { PHPAnalyzer } from './phpAnalyzer';

interface VulnerabilityPattern {
    id: string;
    name: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    description: string;
    remediation: string;
    cwe?: string;
    check: (analyzer: PHPAnalyzer, document: vscode.TextDocument) => Vulnerability[];
}

export class VulnerabilityScanner {
    private ast: any;
    private analyzer: PHPAnalyzer;
    private patterns: VulnerabilityPattern[];
    private taintMap: Map<string, string>;  // variable -> source superglobal

    constructor(ast: any) {
        this.ast = ast;
        this.analyzer = new PHPAnalyzer('');
        this.analyzer['ast'] = ast;
        this.taintMap = new Map();
        this.buildTaintMap();
        this.patterns = this.initializePatterns();
    }

    /**
     * 构建简单污点映射: 记录变量是否直接来自超级全局
     * 仅处理直接赋值场景: $a = $_GET['x']; $b = $_POST;
     */
    private buildTaintMap() {
        const markVar = (name: string, source: string) => {
            if (!name) return;
            this.taintMap.set(name, source);
        };

        this.analyzer.traverse(this.ast, (node) => {
            if (node.kind === 'assign') {
                // 左侧变量
                const left = node.left;
                const right = node.right;

                // 仅处理简单变量
                if (left?.kind === 'variable') {
                    const src = this.getSuperGlobalFromNode(right);
                    if (src) {
                        markVar(left.name, src);
                    }
                }
            }
        });
    }

    /**
     * 如果节点引用了超级全局，返回对应字符串；否则返回空
     */
    private getSuperGlobalFromNode(node: any): string | '' {
        if (!node) return '';

        // $_GET['a'] / $_POST['b']
        if (node.kind === 'offsetlookup' && node.what?.kind === 'variable') {
            const name = node.what.name;
            if (['_GET', '_POST', '_REQUEST', '_COOKIE', '_FILES', '_SERVER'].includes(name)) {
                return '$_' + name.replace('_', '');
            }
        }

        // 直接使用 $_GET
        if (node.kind === 'variable') {
            if (['_GET', '_POST', '_REQUEST', '_COOKIE', '_FILES', '_SERVER'].includes(node.name)) {
                return '$_' + node.name.replace('_', '');
            }
            // 如果是已标记变量，返回其来源
            const mapped = this.taintMap.get(node.name);
            if (mapped) return mapped;
        }

        // 字符串拼接/二元运算，递归检查
        if (node.kind === 'bin') {
            return this.getSuperGlobalFromNode(node.left) || this.getSuperGlobalFromNode(node.right);
        }

        // 字符串插值
        if (node.kind === 'encapsed' && Array.isArray(node.value)) {
            for (const part of node.value) {
                const src = this.getSuperGlobalFromNode(part);
                if (src) return src;
            }
        }

        return '';
    }

    scanVulnerabilities(document: vscode.TextDocument): AnalysisResult[] {
        const results: AnalysisResult[] = [];
        const vulnerabilities: Vulnerability[] = [];

        for (const pattern of this.patterns) {
            const found = pattern.check(this.analyzer, document);
            vulnerabilities.push(...found);
        }

        // Group by severity
        for (const vuln of vulnerabilities) {
            results.push({
                type: 'Vulnerability',
                severity: vuln.severity === 'critical' ? 'critical' : vuln.severity === 'high' ? 'error' : 'warning',
                message: `[${vuln.id}] ${vuln.name}`,
                location: vuln.location,
                details: this.formatVulnerabilityDetails(vuln),
                metadata: vuln
            });
        }

        return results;
    }

    private initializePatterns(): VulnerabilityPattern[] {
        return [
            // DESER-001: Unsafe unserialize
            {
                id: 'DESER-001',
                name: 'Unsafe Deserialization',
                severity: 'critical',
                description: 'User input directly passed to unserialize()',
                remediation: 'Avoid unserializing user input. Use JSON instead.',
                cwe: 'CWE-502',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const calls = analyzer.getAllFunctionCalls();
                    
                    for (const call of calls) {
                        if (this.getFunctionName(call) === 'unserialize') {
                            const source = this.analyzeSource(call);
                            if (this.isUserInput(source)) {
                                const loc = this.getLocation(analyzer, call, document);
                                vulns.push({
                                    id: 'DESER-001',
                                    name: 'Unsafe Deserialization',
                                    severity: 'critical',
                                    description: `unserialize() called with user input from ${source}`,
                                    location: loc,
                                    remediation: 'Use JSON or implement allowed_classes whitelist',
                                    cwe: 'CWE-502'
                                });
                            }
                        }
                    }
                    
                    return vulns;
                }
            },

            // FUNC-001: eval usage
            {
                id: 'FUNC-001',
                name: 'eval() Usage',
                severity: 'critical',
                description: 'Use of eval() function',
                remediation: 'Avoid eval(). Use safer alternatives.',
                cwe: 'CWE-95',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const calls = analyzer.getAllFunctionCalls();
                    
                    for (const call of calls) {
                        if (this.getFunctionName(call) === 'eval') {
                            const loc = this.getLocation(analyzer, call, document);
                            vulns.push({
                                id: 'FUNC-001',
                                name: 'eval() Usage',
                                severity: 'critical',
                                description: 'eval() is extremely dangerous and should be avoided',
                                location: loc,
                                remediation: 'Refactor code to eliminate eval()',
                                cwe: 'CWE-95'
                            });
                        }
                    }
                    
                    return vulns;
                }
            },

            // FUNC-003: Command injection
            {
                id: 'FUNC-003',
                name: 'Command Execution',
                severity: 'critical',
                description: 'Use of command execution functions',
                remediation: 'Validate and escape all inputs to command execution functions',
                cwe: 'CWE-78',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const cmdFuncs = ['system', 'exec', 'passthru', 'shell_exec', 'popen', 'proc_open'];
                    const calls = analyzer.getAllFunctionCalls();
                    
                    for (const call of calls) {
                        const funcName = this.getFunctionName(call);
                        if (cmdFuncs.includes(funcName)) {
                            const loc = this.getLocation(analyzer, call, document);
                            vulns.push({
                                id: 'FUNC-003',
                                name: 'Command Execution',
                                severity: 'critical',
                                description: `Use of ${funcName}() can lead to command injection`,
                                location: loc,
                                remediation: 'Use escapeshellarg() and escapeshellcmd(), or avoid system commands',
                                cwe: 'CWE-78'
                            });
                        }
                    }
                    
                    return vulns;
                }
            },

            // FUNC-004: Dangerous callbacks
            {
                id: 'FUNC-004',
                name: 'Dangerous Callback',
                severity: 'high',
                description: 'Dynamic function calls can be exploited',
                remediation: 'Whitelist allowed callback functions',
                cwe: 'CWE-95',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const callbackFuncs = ['call_user_func', 'call_user_func_array', 'array_map', 'array_filter'];
                    const calls = analyzer.getAllFunctionCalls();
                    
                    for (const call of calls) {
                        const funcName = this.getFunctionName(call);
                        if (callbackFuncs.includes(funcName)) {
                            const source = this.analyzeSource(call);
                            if (this.isUserInput(source)) {
                                const loc = this.getLocation(analyzer, call, document);
                                vulns.push({
                                    id: 'FUNC-004',
                                    name: 'Dangerous Callback',
                                    severity: 'high',
                                    description: `${funcName}() with user-controlled callback from ${source}`,
                                    location: loc,
                                    remediation: 'Implement a whitelist of allowed callbacks',
                                    cwe: 'CWE-95'
                                });
                            }
                        }
                    }
                    
                    return vulns;
                }
            },

            // MAGIC-002: Dangerous __destruct
            {
                id: 'MAGIC-002',
                name: 'Dangerous __destruct',
                severity: 'high',
                description: '__destruct contains dangerous operations',
                remediation: 'Avoid dangerous operations in __destruct',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const classes = analyzer.getAllClasses();
                    
                    for (const classNode of classes) {
                        if (!classNode.body) {continue;}
                        
                        for (const member of classNode.body) {
                            if (member.kind === 'method' && (member.name?.name === '__destruct' || member.name === '__destruct')) {
                                const hasDangerous = this.hasDangerousOps(analyzer, member);
                                if (hasDangerous) {
                                    const loc = this.getLocation(analyzer, member, document);
                                    vulns.push({
                                        id: 'MAGIC-002',
                                        name: 'Dangerous __destruct',
                                        severity: 'high',
                                        description: '__destruct contains dangerous operations that could be exploited',
                                        location: loc,
                                        remediation: 'Remove dangerous operations from __destruct or add input validation'
                                    });
                                }
                            }
                        }
                    }
                    
                    return vulns;
                }
            },

            // PHAR-001: Phar deserialization
            {
                id: 'PHAR-001',
                name: 'Phar Deserialization',
                severity: 'high',
                description: 'File functions can trigger phar:// deserialization',
                remediation: 'Validate file paths and disable phar:// wrapper',
                cwe: 'CWE-502',
                check: (analyzer, document) => {
                    const vulns: Vulnerability[] = [];
                    const pharTriggers = ['file_exists', 'file_get_contents', 'fopen', 'getimagesize', 'is_file'];
                    const calls = analyzer.getAllFunctionCalls();
                    
                    for (const call of calls) {
                        const funcName = this.getFunctionName(call);
                        if (pharTriggers.includes(funcName)) {
                            const source = this.analyzeSource(call);
                            if (this.isUserInput(source)) {
                                const loc = this.getLocation(analyzer, call, document);
                                vulns.push({
                                    id: 'PHAR-001',
                                    name: 'Phar Deserialization',
                                    severity: 'high',
                                    description: `${funcName}() with user input can trigger phar:// deserialization`,
                                    location: loc,
                                    remediation: 'Validate paths with realpath() and basename()',
                                    cwe: 'CWE-502'
                                });
                            }
                        }
                    }
                    
                    return vulns;
                }
            },

            // WEAK-001: intval() weak type comparison bypass
            {
                id: 'WEAK-001',
                name: 'intval() Bypass Vulnerability',
                severity: 'high',
                description: 'intval() with different base parameters can be bypassed',
                remediation: 'Use strict type checking or consistent intval() calls',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkIntvalBypass(analyzer, document);
                }
            },

            // WEAK-002: Loose comparison (== vs ===)
            {
                id: 'WEAK-002',
                name: 'Loose Comparison Vulnerability',
                severity: 'medium',
                description: 'Loose comparison (==) can lead to type juggling attacks',
                remediation: 'Use strict comparison (===) instead',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkLooseComparison(analyzer, document);
                }
            },

            // WEAK-003: MD5/SHA1 comparison bypass
            {
                id: 'WEAK-003',
                name: 'Hash Comparison Bypass',
                severity: 'high',
                description: 'MD5/SHA1 comparison with == can be bypassed with magic hashes',
                remediation: 'Use hash_equals() or strict comparison (===)',
                cwe: 'CWE-328',
                check: (analyzer, document) => {
                    return this.checkHashComparisonBypass(analyzer, document);
                }
            },

            // WEAK-004: preg_match bypass with newline
            {
                id: 'WEAK-004',
                name: 'preg_match Bypass',
                severity: 'medium',
                description: 'preg_match without /s or /D modifier can be bypassed',
                remediation: 'Use /s modifier or anchor with \\z instead of $',
                cwe: 'CWE-185',
                check: (analyzer, document) => {
                    return this.checkPregMatchBypass(analyzer, document);
                }
            },

            // WEAK-005: is_numeric bypass
            {
                id: 'WEAK-005',
                name: 'is_numeric Bypass',
                severity: 'medium',
                description: 'is_numeric() accepts hex (0x) and scientific notation',
                remediation: 'Use ctype_digit() for strict numeric check',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkIsNumericBypass(analyzer, document);
                }
            },

            // WEAK-006: strcmp bypass with array
            {
                id: 'WEAK-006',
                name: 'strcmp Array Bypass',
                severity: 'high',
                description: 'strcmp() returns NULL when comparing with array, bypassing == 0 check',
                remediation: 'Validate input type before strcmp() or use ===',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkStrcmpBypass(analyzer, document);
                }
            },

            // WEAK-007: in_array loose comparison
            {
                id: 'WEAK-007',
                name: 'in_array Loose Comparison',
                severity: 'medium',
                description: 'in_array() uses loose comparison by default',
                remediation: 'Set third parameter to true: in_array($needle, $haystack, true)',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkInArrayLoose(analyzer, document);
                }
            },

            // WEAK-008: switch loose comparison
            {
                id: 'WEAK-008',
                name: 'Switch Loose Comparison',
                severity: 'medium',
                description: 'switch uses loose comparison, can be bypassed with type juggling',
                remediation: 'Add explicit type check before switch or use if-elseif with ===',
                cwe: 'CWE-1024',
                check: (analyzer, document) => {
                    return this.checkSwitchLoose(analyzer, document);
                }
            },

            // LFI-001: Local File Inclusion
            {
                id: 'LFI-001',
                name: 'Local File Inclusion (LFI)',
                severity: 'critical',
                description: 'User input in file inclusion functions',
                remediation: 'Use whitelist for allowed files',
                cwe: 'CWE-98',
                check: (analyzer, document) => {
                    return this.checkFileInclusion(analyzer, document);
                }
            },

            // VAR-001: Variable Override
            {
                id: 'VAR-001',
                name: 'Variable Override Vulnerability',
                severity: 'high',
                description: 'Functions that can override variables from user input',
                remediation: 'Avoid extract/parse_str or use EXTR_SKIP flag',
                cwe: 'CWE-621',
                check: (analyzer, document) => {
                    return this.checkVariableOverride(analyzer, document);
                }
            },

            // SQL-001: SQL Injection
            {
                id: 'SQL-001',
                name: 'SQL Injection',
                severity: 'critical',
                description: 'User input directly in SQL queries',
                remediation: 'Use prepared statements with parameterized queries',
                cwe: 'CWE-89',
                check: (analyzer, document) => {
                    return this.checkSQLInjection(analyzer, document);
                }
            },

            // SSRF-001: Server-Side Request Forgery
            {
                id: 'SSRF-001',
                name: 'Server-Side Request Forgery (SSRF)',
                severity: 'high',
                description: 'User input in URL fetching functions',
                remediation: 'Whitelist allowed domains and validate URLs',
                cwe: 'CWE-918',
                check: (analyzer, document) => {
                    return this.checkSSRF(analyzer, document);
                }
            },

            // XXE-001: XML External Entity
            {
                id: 'XXE-001',
                name: 'XML External Entity (XXE)',
                severity: 'high',
                description: 'XML parsing without disabling external entities',
                remediation: 'Disable external entity loading with libxml_disable_entity_loader(true)',
                cwe: 'CWE-611',
                check: (analyzer, document) => {
                    return this.checkXXE(analyzer, document);
                }
            }
        ];
    }

    // 检测 intval() 绕过漏洞
    private checkIntvalBypass(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        
        // 查找 intval 调用模式
        const intvalCalls: Array<{line: number, hasBase: boolean, base: number | null, context: string}> = [];
        const calls = analyzer.getAllFunctionCalls();
        
        for (const call of calls) {
            if (this.getFunctionName(call) === 'intval') {
                const line = call.loc?.start?.line || 0;
                const args = call.arguments || [];
                const hasBase = args.length >= 2;
                let base: number | null = null;
                
                if (hasBase && args[1]?.kind === 'number') {
                    // php-parser 返回的 value 可能是字符串或数字
                    base = Number(args[1].value);
                } else if (hasBase && args[1]?.kind === 'variable') {
                    // 检查是否使用了变量作为基数（如 0 表示自动检测）
                    base = 0;
                }
                
                intvalCalls.push({ line, hasBase, base, context: this.getLineText(text, line) });
            }
        }
        
        // 检测 intval($x) != Y && intval($x, 0) == Y 模式
        // 这是典型的绕过场景：intval("0x2f") = 0, 但 intval("0x2f", 0) = 47
        if (intvalCalls.length >= 2) {
            const withoutBase = intvalCalls.filter(c => !c.hasBase);
            const withBase0 = intvalCalls.filter(c => c.base === 0);
            
            if (withoutBase.length > 0 && withBase0.length > 0) {
                const loc = new vscode.Location(document.uri, new vscode.Position(withoutBase[0].line - 1, 0));
                vulns.push({
                    id: 'WEAK-001',
                    name: 'intval() Bypass Vulnerability',
                    severity: 'high',
                    description: `检测到 intval() 弱类型绕过漏洞！\n` +
                        `- intval($x) 默认使用10进制\n` +
                        `- intval($x, 0) 自动检测进制(支持0x前缀)\n` +
                        `绕过方法: 使用十六进制字符串，如 "0x2f" (十进制47)`,
                    location: loc,
                    remediation: `Payload示例:\n` +
                        `- 目标值47: 提交 "0x2f" 或 "0b101111"\n` +
                        `- intval("0x2f") = 0 (不识别)\n` +
                        `- intval("0x2f", 0) = 47 (自动识别十六进制)`,
                    cwe: 'CWE-1024'
                });
            }
        }
        
        // 单独的 intval 检查
        for (const call of intvalCalls) {
            if (call.base === 0) {
                const loc = new vscode.Location(document.uri, new vscode.Position(call.line - 1, 0));
                vulns.push({
                    id: 'WEAK-001',
                    name: 'intval() with Auto-detect Base',
                    severity: 'medium',
                    description: `intval($var, 0) 会自动检测进制:\n` +
                        `- "0x2f" → 47 (十六进制)\n` +
                        `- "0b101111" → 47 (二进制)\n` +
                        `- "057" → 47 (八进制)`,
                    location: loc,
                    remediation: '如果需要严格的十进制解析，使用 intval($var, 10)',
                    cwe: 'CWE-1024'
                });
            }
        }
        
        return vulns;
    }

    // 检测松散比较漏洞
    private checkLooseComparison(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        // 检测 == 和 != 用于安全相关比较
        const looseCompPattern = /(\$\w+)\s*(==|!=)\s*(['"]?\w+['"]?|\d+)/g;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            let match;
            
            while ((match = looseCompPattern.exec(line)) !== null) {
                // 检查是否在 if 条件中
                if (line.includes('if') && (line.includes('password') || line.includes('token') || 
                    line.includes('admin') || line.includes('auth') || line.includes('flag'))) {
                    const loc = new vscode.Location(document.uri, new vscode.Position(i, match.index));
                    vulns.push({
                        id: 'WEAK-002',
                        name: 'Loose Comparison in Security Check',
                        severity: 'high',
                        description: `松散比较 "${match[2]}" 可被类型混淆绕过:\n` +
                            `- "0" == 0 → true\n` +
                            `- "0e123" == 0 → true (科学计数法)\n` +
                            `- [] == false → true`,
                        location: loc,
                        remediation: `使用严格比较 === 或 !==`,
                        cwe: 'CWE-1024'
                    });
                }
            }
        }
        
        return vulns;
    }

    // 检测 MD5/SHA1 魔法哈希绕过
    private checkHashComparisonBypass(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // 检测 md5($x) == md5($y) 或类似模式
            if ((line.includes('md5(') || line.includes('sha1(')) && 
                (line.includes('==') && !line.includes('==='))) {
                const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                vulns.push({
                    id: 'WEAK-003',
                    name: 'Hash Magic Comparison Bypass',
                    severity: 'high',
                    description: `MD5/SHA1 与 == 比较可被魔法哈希绕过:\n` +
                        `- md5("240610708") = "0e462097431906509019562988736854"\n` +
                        `- md5("QNKCDZO") = "0e830400451993494058024219903391"\n` +
                        `- 0e... == 0e... → true (都被解析为0)`,
                    location: loc,
                    remediation: `Payload: 使用魔法哈希字符串:\n` +
                        `MD5: 240610708, QNKCDZO, s878926199a\n` +
                        `SHA1: 10932435112\n` +
                        `或使用 hash_equals() 函数`,
                    cwe: 'CWE-328'
                });
            }
        }
        
        return vulns;
    }

    // 检测 preg_match 绕过
    private checkPregMatchBypass(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        
        for (const call of calls) {
            if (this.getFunctionName(call) === 'preg_match') {
                const args = call.arguments || [];
                if (args.length >= 1 && args[0].kind === 'string') {
                    const pattern = args[0].value || '';
                    
                    // 检查是否使用 $ 但没有 /D 或 /s 修饰符
                    if (pattern.includes('$') && !pattern.includes('/s') && !pattern.includes('/D')) {
                        const loc = this.getLocation(analyzer, call, document);
                        vulns.push({
                            id: 'WEAK-004',
                            name: 'preg_match Newline Bypass',
                            severity: 'medium',
                            description: `正则 ${pattern} 可被换行符绕过:\n` +
                                `- $ 匹配字符串末尾或换行符前\n` +
                                `- 添加 %0a 可绕过末尾检查`,
                            location: loc,
                            remediation: `使用 /D 修饰符或 \\z 替代 $`,
                            cwe: 'CWE-185'
                        });
                    }
                    
                    // 检查是否只使用 ^ 和 $ 但没有多行标志问题
                    if (pattern.includes('^') && pattern.includes('$') && !pattern.includes('/m')) {
                        // 这种情况通常是安全的，但如果输入包含换行可能有问题
                    }
                }
            }
        }
        
        return vulns;
    }

    // 检测 is_numeric 绕过
    private checkIsNumericBypass(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        
        for (const call of calls) {
            if (this.getFunctionName(call) === 'is_numeric') {
                const loc = this.getLocation(analyzer, call, document);
                vulns.push({
                    id: 'WEAK-005',
                    name: 'is_numeric() Accepts Special Formats',
                    severity: 'medium',
                    description: `is_numeric() 接受特殊格式:\n` +
                        `- "0x1A" → true (十六进制, PHP < 7)\n` +
                        `- "1e2" → true (科学计数法 = 100)\n` +
                        `- "  123" → true (带空格)`,
                    location: loc,
                    remediation: `使用 ctype_digit() 进行严格数字检查\n` +
                        `或使用 preg_match('/^\\d+$/', $var)`,
                    cwe: 'CWE-1024'
                });
            }
        }
        
        return vulns;
    }

    // 检测 strcmp 数组绕过
    private checkStrcmpBypass(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.includes('strcmp(') && (line.includes('== 0') || line.includes('==0') || 
                line.includes('!strcmp'))) {
                const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                vulns.push({
                    id: 'WEAK-006',
                    name: 'strcmp Array Bypass',
                    severity: 'high',
                    description: `strcmp() 与数组比较返回 NULL:\n` +
                        `- strcmp($_POST['pass'], "secret") == 0\n` +
                        `- 传入 pass[]=x，strcmp 返回 NULL\n` +
                        `- NULL == 0 → true (绕过!)`,
                    location: loc,
                    remediation: `Payload: param[]=任意值\n` +
                        `修复: 使用 === 0 或先验证类型`,
                    cwe: 'CWE-1024'
                });
            }
        }
        
        return vulns;
    }

    // 检测 in_array 松散比较
    private checkInArrayLoose(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        
        for (const call of calls) {
            if (this.getFunctionName(call) === 'in_array') {
                const args = call.arguments || [];
                // 如果只有2个参数，第3个参数默认为false（松散比较）
                if (args.length === 2) {
                    const loc = this.getLocation(analyzer, call, document);
                    vulns.push({
                        id: 'WEAK-007',
                        name: 'in_array Loose Comparison',
                        severity: 'medium',
                        description: `in_array() 默认使用松散比较:\n` +
                            `- in_array(0, ["a", "b"]) → true\n` +
                            `- in_array("0", [0, 1, 2]) → true`,
                        location: loc,
                        remediation: `使用严格模式: in_array($val, $arr, true)`,
                        cwe: 'CWE-1024'
                    });
                }
            }
        }
        
        return vulns;
    }

    // 检测 switch 松散比较
    private checkSwitchLoose(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        
        analyzer.traverse(this.ast, (node) => {
            if (node.kind === 'switch') {
                // 检查 switch 条件是否来自用户输入
                const test = node.test;
                if (test?.kind === 'offsetlookup' || 
                    (test?.kind === 'variable' && this.isUserInput('$' + test.name))) {
                    const loc = this.getLocation(analyzer, node, document);
                    vulns.push({
                        id: 'WEAK-008',
                        name: 'Switch Loose Type Comparison',
                        severity: 'medium',
                        description: `switch 使用松散比较:\n` +
                            `- switch("0abc") case 0: 会匹配!\n` +
                            `- switch(0) case "admin": 会匹配!`,
                        location: loc,
                        remediation: `在 switch 前添加类型验证\n` +
                            `或使用 if-elseif 配合 ===`,
                        cwe: 'CWE-1024'
                    });
                }
            }
        });
        
        return vulns;
    }

    // 检测文件包含漏洞
    private checkFileInclusion(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        const includeFuncs = ['include', 'include_once', 'require', 'require_once'];
        
        // 检查 AST 中的 include 语句
        analyzer.traverse(this.ast, (node) => {
            if (node.kind === 'include') {
                const target = node.target;
                let isUserControlled = false;
                let source = '';
                
                // 检查是否包含用户输入
                if (target?.kind === 'variable') {
                    const varName = target.name;
                    source = '$' + varName;
                    // 检查 taint map 是否标记该变量来自用户输入
                    const taintSource = this.taintMap.get(varName);
                    if (taintSource) {
                        isUserControlled = true;
                        source = taintSource + ' → $' + varName;
                    } else if (this.isUserInput(source)) {
                        isUserControlled = true;
                    }
                } else if (target?.kind === 'offsetlookup') {
                    source = this.getOffsetLookupSource(target);
                    isUserControlled = this.isUserInput(source);
                } else if (target?.kind === 'encapsed') {
                    // 检查字符串插值中是否有用户输入
                    for (const part of (target.value || [])) {
                        if (part.kind === 'variable') {
                            const varName = part.name;
                            source = '$' + varName;
                            const taintSource = this.taintMap.get(varName);
                            if (taintSource) {
                                isUserControlled = true;
                                source = taintSource + ' → $' + varName;
                                break;
                            }
                        } else if (part.kind === 'offsetlookup') {
                            source = this.getOffsetLookupSource(part);
                            if (this.isUserInput(source)) {
                                isUserControlled = true;
                                break;
                            }
                        }
                    }
                } else if (target?.kind === 'bin' && target.type === '.') {
                    // 字符串拼接
                    isUserControlled = this.checkBinOpForUserInput(target);
                    source = '拼接字符串';
                }
                
                if (isUserControlled) {
                    const loc = this.getLocation(analyzer, node, document);
                    vulns.push({
                        id: 'LFI-001',
                        name: 'Local File Inclusion (LFI)',
                        severity: 'critical',
                        description: `文件包含存在用户可控输入: ${source}\n\n` +
                            `可利用的PHP伪协议:\n` +
                            `- php://filter/read=convert.base64-encode/resource=文件名\n` +
                            `- php://input (需要POST数据)\n` +
                            `- data://text/plain,<?php phpinfo();?>\n` +
                            `- phar://恶意.phar\n` +
                            `- zip://压缩包#内部文件`,
                        location: loc,
                        remediation: `Payload示例:\n` +
                            `1. 读取源码: php://filter/read=convert.base64-encode/resource=index.php\n` +
                            `2. 读取flag: php://filter/read=convert.base64-encode/resource=flag.php\n` +
                            `3. 代码执行: data://text/plain,<?php system('whoami');?>\n` +
                            `4. 日志包含: /var/log/apache2/access.log (需注入恶意UA)`,
                        cwe: 'CWE-98'
                    });
                }
            }
        });
        
        // 额外检查文本模式
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            for (const func of includeFuncs) {
                const regex = new RegExp(`${func}\\s*\\(.*\\$_(GET|POST|REQUEST|COOKIE)`, 'i');
                if (regex.test(line)) {
                    const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                    if (!vulns.some(v => v.location.range.start.line === i)) {
                        vulns.push({
                            id: 'LFI-001',
                            name: 'Local File Inclusion (LFI)',
                            severity: 'critical',
                            description: `检测到 ${func}() 包含用户输入`,
                            location: loc,
                            remediation: '使用白名单验证文件名',
                            cwe: 'CWE-98'
                        });
                    }
                }
            }
        }
        
        return vulns;
    }

    // 检测变量覆盖漏洞
    private checkVariableOverride(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        const text = document.getText();
        const lines = text.split('\n');
        
        for (const call of calls) {
            const funcName = this.getFunctionName(call);
            
            // extract() 漏洞
            if (funcName === 'extract') {
                const source = this.analyzeSource(call);
                const args = call.arguments || [];
                
                // 检查是否使用了 EXTR_SKIP 标志
                const hasSkipFlag = args.length >= 2 && 
                    args[1]?.kind === 'constref' && 
                    args[1]?.name?.name === 'EXTR_SKIP';
                
                if (this.isUserInput(source) || !hasSkipFlag) {
                    const loc = this.getLocation(analyzer, call, document);
                    vulns.push({
                        id: 'VAR-001',
                        name: 'Variable Override via extract()',
                        severity: 'high',
                        description: `extract() 可以覆盖已有变量:\n` +
                            `- 覆盖 $admin = true\n` +
                            `- 覆盖 $auth = 1\n` +
                            `- 覆盖重要配置变量`,
                        location: loc,
                        remediation: `Payload: ?admin=1&auth=1\n` +
                            `修复: 使用 extract($data, EXTR_SKIP)`,
                        cwe: 'CWE-621'
                    });
                }
            }
            
            // parse_str() 漏洞
            if (funcName === 'parse_str') {
                const args = call.arguments || [];
                // PHP7+ 没有第二个参数会报错，但老版本会直接覆盖全局变量
                if (args.length === 1) {
                    const loc = this.getLocation(analyzer, call, document);
                    vulns.push({
                        id: 'VAR-001',
                        name: 'Variable Override via parse_str()',
                        severity: 'high',
                        description: `parse_str() 没有第二个参数会覆盖全局变量 (PHP < 7.2)`,
                        location: loc,
                        remediation: `使用 parse_str($str, $result) 并使用 $result 数组`,
                        cwe: 'CWE-621'
                    });
                }
            }
            
            // import_request_variables() - PHP < 5.4
            if (funcName === 'import_request_variables') {
                const loc = this.getLocation(analyzer, call, document);
                vulns.push({
                    id: 'VAR-001',
                    name: 'Variable Override via import_request_variables()',
                    severity: 'critical',
                    description: `import_request_variables() 将请求变量导入全局作用域`,
                    location: loc,
                    remediation: `移除此函数，使用 $_GET/$_POST`,
                    cwe: 'CWE-621'
                });
            }
        }
        
        // 检测 $$ 变量变量
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (/\$\$\w+\s*=/.test(line) || /\${\$\w+}\s*=/.test(line)) {
                // 检查是否来自用户输入
                if (line.includes('$_GET') || line.includes('$_POST') || 
                    line.includes('$_REQUEST') || line.includes('foreach')) {
                    const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                    vulns.push({
                        id: 'VAR-001',
                        name: 'Variable Variable Override',
                        severity: 'high',
                        description: `$$var 可以覆盖任意变量:\n` +
                            `foreach($_GET as $k => $v) $$k = $v;`,
                        location: loc,
                        remediation: `避免使用 $$，或验证变量名白名单`,
                        cwe: 'CWE-621'
                    });
                }
            }
        }
        
        return vulns;
    }

    // 检测 SQL 注入
    private checkSQLInjection(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const text = document.getText();
        const lines = text.split('\n');
        
        // SQL 相关函数和方法
        const sqlFuncs = ['mysql_query', 'mysqli_query', 'pg_query', 'sqlite_query', 
                          'query', 'exec', 'prepare', 'execute'];
        
        const calls = analyzer.getAllFunctionCalls();
        
        for (const call of calls) {
            const funcName = this.getFunctionName(call);
            if (sqlFuncs.includes(funcName)) {
                const args = call.arguments || [];
                
                // 检查参数是否包含用户输入（包括通过变量间接引用）
                for (const arg of args) {
                    let isUserControlled = false;
                    let source = '';
                    
                    if (arg?.kind === 'variable') {
                        const varName = arg.name;
                        const taintSource = this.taintMap.get(varName);
                        if (taintSource) {
                            isUserControlled = true;
                            source = taintSource + ' → $' + varName;
                        }
                    } else if (this.containsUserInput(arg)) {
                        isUserControlled = true;
                        source = '用户输入';
                    }
                    
                    if (isUserControlled) {
                        const loc = this.getLocation(analyzer, call, document);
                        vulns.push({
                            id: 'SQL-001',
                            name: 'SQL Injection',
                            severity: 'critical',
                            description: `${funcName}() 包含用户输入 (${source})，存在SQL注入风险\n\n` +
                                `常见绕过技巧:\n` +
                                `- 注释: --+, #, /**/\n` +
                                `- 大小写: SeLeCt, UniOn\n` +
                                `- 双写: selselectect\n` +
                                `- 编码: char(), 0x...\n` +
                                `- 空格替代: /**/、%09、%0a、%0d`,
                            location: loc,
                            remediation: `Payload示例:\n` +
                                `- ' OR 1=1 --+\n` +
                                `- ' UNION SELECT 1,2,3 --+\n` +
                                `- 1' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --+\n\n` +
                                `修复: 使用预处理语句 prepare() + bind_param()`,
                            cwe: 'CWE-89'
                        });
                        break;
                    }
                }
            }
        }
        
        // 检查字符串拼接的 SQL - 检测 $sql = "SELECT ... $var" 模式
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // 直接使用超级全局变量
            const sqlPattern = /(SELECT|INSERT|UPDATE|DELETE|WHERE).*\$_(GET|POST|REQUEST|COOKIE)/i;
            if (sqlPattern.test(line)) {
                const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                if (!vulns.some(v => v.location.range.start.line === i)) {
                    vulns.push({
                        id: 'SQL-001',
                        name: 'SQL Injection (String Concat)',
                        severity: 'critical',
                        description: `SQL语句直接拼接用户输入`,
                        location: loc,
                        remediation: `使用预处理语句`,
                        cwe: 'CWE-89'
                    });
                }
            }
            
            // 检测通过变量拼接的SQL: $sql = "SELECT ... '$id'" 其中 $id 来自用户
            const sqlVarPattern = /(SELECT|INSERT|UPDATE|DELETE|WHERE).*['"].*\$(\w+)/i;
            const match = sqlVarPattern.exec(line);
            if (match) {
                const varName = match[2];
                const taintSource = this.taintMap.get(varName);
                if (taintSource) {
                    const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                    if (!vulns.some(v => v.location.range.start.line === i)) {
                        vulns.push({
                            id: 'SQL-001',
                            name: 'SQL Injection (Variable Concat)',
                            severity: 'critical',
                            description: `SQL语句拼接了受污染变量: ${taintSource} → $${varName}`,
                            location: loc,
                            remediation: `使用预处理语句 prepare() + bind_param()`,
                            cwe: 'CWE-89'
                        });
                    }
                }
            }
        }
        
        return vulns;
    }

    // 检测 SSRF
    private checkSSRF(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        
        const ssrfFuncs = ['file_get_contents', 'curl_exec', 'curl_init', 'fopen', 
                          'readfile', 'file', 'get_headers', 'fsockopen'];
        
        for (const call of calls) {
            const funcName = this.getFunctionName(call);
            
            if (ssrfFuncs.includes(funcName)) {
                const source = this.analyzeSource(call);
                
                if (this.isUserInput(source)) {
                    const loc = this.getLocation(analyzer, call, document);
                    vulns.push({
                        id: 'SSRF-001',
                        name: 'Server-Side Request Forgery (SSRF)',
                        severity: 'high',
                        description: `${funcName}() 使用用户可控URL:\n\n` +
                            `利用方式:\n` +
                            `- 探测内网: http://127.0.0.1:端口\n` +
                            `- 读取文件: file:///etc/passwd\n` +
                            `- 云服务元数据: http://169.254.169.254/\n` +
                            `- dict协议: dict://127.0.0.1:6379/info`,
                        location: loc,
                        remediation: `Payload示例:\n` +
                            `- 内网探测: http://192.168.1.1/admin\n` +
                            `- Redis未授权: dict://127.0.0.1:6379/CONFIG SET dir /var/www/html\n` +
                            `- 读取passwd: file:///etc/passwd\n` +
                            `- AWS元数据: http://169.254.169.254/latest/meta-data/\n\n` +
                            `修复: 白名单验证URL、禁用危险协议`,
                        cwe: 'CWE-918'
                    });
                }
            }
            
            // 检测 curl_setopt 设置 URL
            if (funcName === 'curl_setopt') {
                const args = call.arguments || [];
                if (args.length >= 3) {
                    // 检查是否设置 CURLOPT_URL
                    const option = args[1];
                    if (option?.kind === 'constref' && option?.name?.name === 'CURLOPT_URL') {
                        if (this.containsUserInput(args[2])) {
                            const loc = this.getLocation(analyzer, call, document);
                            vulns.push({
                                id: 'SSRF-001',
                                name: 'SSRF via curl_setopt',
                                severity: 'high',
                                description: `curl CURLOPT_URL 设置为用户输入`,
                                location: loc,
                                remediation: `验证URL白名单`,
                                cwe: 'CWE-918'
                            });
                        }
                    }
                }
            }
        }
        
        return vulns;
    }

    // 检测 XXE
    private checkXXE(analyzer: PHPAnalyzer, document: vscode.TextDocument): Vulnerability[] {
        const vulns: Vulnerability[] = [];
        const calls = analyzer.getAllFunctionCalls();
        const text = document.getText();
        
        const xmlFuncs = ['simplexml_load_string', 'simplexml_load_file', 
                          'xml_parse', 'loadxml'];
        
        // 检查是否正确禁用了外部实体（注意: LIBXML_NOENT 是启用不是禁用！）
        const hasDisableEntityLoader = text.includes('libxml_disable_entity_loader(true)');
        // LIBXML_NOENT 表示替换实体，实际上是不安全的
        const usesLibxmlNoent = text.includes('LIBXML_NOENT');
        
        for (const call of calls) {
            const funcName = this.getFunctionName(call);
            
            if (xmlFuncs.includes(funcName)) {
                const args = call.arguments || [];
                let isUserControlled = false;
                let source = '';
                
                // 检查第一个参数是否来自用户输入
                if (args.length > 0) {
                    const firstArg = args[0];
                    if (firstArg?.kind === 'variable') {
                        const varName = firstArg.name;
                        const taintSource = this.taintMap.get(varName);
                        if (taintSource) {
                            isUserControlled = true;
                            source = taintSource + ' → $' + varName;
                        }
                    } else if (this.containsUserInput(firstArg)) {
                        isUserControlled = true;
                        source = '用户输入';
                    }
                }
                
                // 如果使用 LIBXML_NOENT 或未禁用实体加载，则有风险
                if (isUserControlled && (!hasDisableEntityLoader || usesLibxmlNoent)) {
                    const loc = this.getLocation(analyzer, call, document);
                    vulns.push({
                        id: 'XXE-001',
                        name: 'XML External Entity (XXE)',
                        severity: 'high',
                        description: `${funcName}() 解析用户提供的XML (${source})` +
                            (usesLibxmlNoent ? '\n⚠️ 使用了 LIBXML_NOENT，会处理外部实体！' : '') +
                            `\n\n利用方式:\n` +
                            `- 读取文件\n` +
                            `- SSRF\n` +
                            `- DOS攻击`,
                        location: loc,
                        remediation: `Payload示例:\n` +
                            `<?xml version="1.0"?>\n` +
                            `<!DOCTYPE foo [\n` +
                            `  <!ENTITY xxe SYSTEM "file:///etc/passwd">\n` +
                            `]>\n` +
                            `<data>&xxe;</data>\n\n` +
                            `或使用 php://filter 读取源码:\n` +
                            `<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=flag.php">\n\n` +
                            `修复: 不要使用 LIBXML_NOENT，使用 libxml_disable_entity_loader(true)`,
                        cwe: 'CWE-611'
                    });
                }
            }
        }
        
        // 检查 new DOMDocument() 后的 loadXML - 通过文本匹配
        if (text.includes('new DOMDocument') || text.includes('new SimpleXMLElement')) {
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // 检查 loadXML 调用，同时检查变量是否被污染
                if (line.includes('loadXML') || line.includes('simplexml_import_dom')) {
                    // 提取变量名
                    const varMatch = line.match(/loadXML\s*\(\s*\$(\w+)/);
                    if (varMatch) {
                        const varName = varMatch[1];
                        const taintSource = this.taintMap.get(varName);
                        if (taintSource && (!hasDisableEntityLoader || usesLibxmlNoent)) {
                            const loc = new vscode.Location(document.uri, new vscode.Position(i, 0));
                            if (!vulns.some(v => v.location.range.start.line === i)) {
                                vulns.push({
                                    id: 'XXE-001',
                                    name: 'XXE via DOMDocument::loadXML',
                                    severity: 'high',
                                    description: `DOMDocument loadXML 解析用户XML (${taintSource} → $${varName})` +
                                        (usesLibxmlNoent ? '\n⚠️ 使用了 LIBXML_NOENT，会处理外部实体！' : ''),
                                    location: loc,
                                    remediation: `在 loadXML 前调用 libxml_disable_entity_loader(true)`,
                                    cwe: 'CWE-611'
                                });
                            }
                        }
                    }
                }
            }
        }
        
        return vulns;
    }

    // 辅助方法: 获取 offsetlookup 的源
    private getOffsetLookupSource(node: any): string {
        if (node.what?.kind === 'variable') {
            return '$' + node.what.name;
        }
        return '';
    }

    // 辅助方法: 检查二元操作是否包含用户输入
    private checkBinOpForUserInput(node: any): boolean {
        if (!node) return false;
        if (node.kind === 'offsetlookup') {
            return this.isUserInput(this.getOffsetLookupSource(node));
        }
        if (node.kind === 'variable') {
            // 可能需要更复杂的追踪
            const src = this.getSuperGlobalFromNode(node);
            return !!src;
        }
        if (node.kind === 'bin') {
            return this.checkBinOpForUserInput(node.left) || 
                   this.checkBinOpForUserInput(node.right);
        }
        return false;
    }

    // 辅助方法: 检查节点是否包含用户输入
    private containsUserInput(node: any): boolean {
        if (!node) return false;
        const src = this.getSuperGlobalFromNode(node);
        if (src) return true;

        if (node.kind === 'offsetlookup') {
            return this.isUserInput(this.getOffsetLookupSource(node));
        }
        if (node.kind === 'variable') {
            return this.isUserInput('$' + node.name);
        }
        if (node.kind === 'bin') {
            return this.checkBinOpForUserInput(node);
        }
        if (node.kind === 'encapsed') {
            for (const part of (node.value || [])) {
                if (this.containsUserInput(part)) return true;
            }
        }
        
        return false;
    }

    private getLineText(text: string, lineNumber: number): string {
        const lines = text.split('\n');
        return lines[lineNumber - 1] || '';
    }

    private getFunctionName(callNode: any): string {
        if (!callNode.what) {return '';}
        // 直接函数调用: funcName()
        if (typeof callNode.what.name === 'string') {return callNode.what.name.toLowerCase();}
        if (callNode.what.kind === 'name') {return (callNode.what.name || '').toLowerCase();}
        // 方法调用: $obj->method() 或 ClassName::method()
        if (callNode.what.kind === 'propertylookup' || callNode.what.kind === 'staticlookup') {
            const offset = callNode.what.offset;
            if (offset?.kind === 'identifier') {
                return (offset.name || '').toLowerCase();
            }
            if (typeof offset === 'string') {
                return offset.toLowerCase();
            }
        }
        return '';
    }

    private analyzeSource(callNode: any): string {
        if (!callNode.arguments || callNode.arguments.length === 0) {return 'unknown';}
        const firstArg = callNode.arguments[0];

        // 如果参数里直接包含超级全局，返回对应标记
        const directSrc = this.getSuperGlobalFromNode(firstArg);
        if (directSrc) {
            return directSrc;
        }
        
        if (firstArg.kind === 'variable') {
            const name = firstArg.name || 'unknown';
            const tainted = this.taintMap.get(name);
            return tainted ? tainted : '$' + name;
        } else if (firstArg.kind === 'offsetlookup' && firstArg.what?.kind === 'variable') {
            const name = firstArg.what.name;
            const tainted = this.taintMap.get(name);
            return tainted ? tainted : '$' + name;
        }
        
        return firstArg.kind || 'unknown';
    }

    private isUserInput(source: string): boolean {
        const inputs = ['$_GET', '$_POST', '$_COOKIE', '$_REQUEST', '$_FILES', '$_SERVER'];
        // 已经直接标记为超级全局
        if (inputs.some(input => source.includes(input))) return true;

        // 如果是变量名，检查污点映射
        if (source.startsWith('$')) {
            const name = source.replace('$', '');
            return this.taintMap.has(name);
        }
        return false;
    }

    private hasDangerousOps(analyzer: PHPAnalyzer, node: any): boolean {
        let found = false;
        analyzer.traverse(node, (child) => {
            if (child.kind === 'call' && child.what) {
                const funcName = this.getFunctionName(child);
                if (analyzer.isDangerousFunction(funcName)) {
                    found = true;
                }
            }
        });
        return found;
    }

    private getLocation(analyzer: PHPAnalyzer, node: any, document: vscode.TextDocument): vscode.Location {
        const loc = analyzer.getNodeLocation(node);
        const position = loc ? new vscode.Position(loc.line, loc.character) : new vscode.Position(0, 0);
        return new vscode.Location(document.uri, position);
    }

    private formatVulnerabilityDetails(vuln: Vulnerability): string {
        let details = `ID: ${vuln.id}\n`;
        details += `Severity: ${vuln.severity.toUpperCase()}\n`;
        if (vuln.cwe) {
            details += `CWE: ${vuln.cwe}\n`;
        }
        details += `\nDescription:\n${vuln.description}\n`;
        details += `\nRemediation:\n${vuln.remediation}`;
        return details;
    }
}
